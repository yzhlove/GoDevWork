package main

import (
	"fmt"
	"math/big"
)

//////////////////////////////////////////////////////////////////////////////////////////
//我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：
//
//甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，
//然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙；
//乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，
//乙再同时计算s=A^b mod p，结果是121；
//乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。
//所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。
//而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。
//
//所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，
//而这个密钥不会通过网络传输。
//
//如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，
//DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，
//然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，
//DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。
//////////////////////////////////////////////////////////////////////////////////////////

func main() {

	//甲

	var p = big.NewInt(509)
	var g = big.NewInt(5)
	var a = big.NewInt(123)

	A := big.NewInt(0).Exp(g, a, p)
	fmt.Println("A = ", A.String())

	//乙 -> p , g , A

	var b = big.NewInt(456)
	B := big.NewInt(0).Exp(g, b, p)
	fmt.Println("B = ", B.String())

	//验证

	b_secret := big.NewInt(0).Exp(A, b, p)
	fmt.Println("secret = ", b_secret.String())

	//甲 -> B
	a_secret := big.NewInt(0).Exp(B, a, p)
	fmt.Println("secret = ", a_secret.String())

}
