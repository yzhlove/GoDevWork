// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pubsubservice.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type String struct {
	Var                  string   `protobuf:"bytes,1,opt,name=Var,proto3" json:"Var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *String) Reset()         { *m = String{} }
func (m *String) String() string { return proto.CompactTextString(m) }
func (*String) ProtoMessage()    {}
func (*String) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a3c17a182e409fe, []int{0}
}

func (m *String) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_String.Unmarshal(m, b)
}
func (m *String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_String.Marshal(b, m, deterministic)
}
func (m *String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_String.Merge(m, src)
}
func (m *String) XXX_Size() int {
	return xxx_messageInfo_String.Size(m)
}
func (m *String) XXX_DiscardUnknown() {
	xxx_messageInfo_String.DiscardUnknown(m)
}

var xxx_messageInfo_String proto.InternalMessageInfo

func (m *String) GetVar() string {
	if m != nil {
		return m.Var
	}
	return ""
}

func init() {
	proto.RegisterType((*String)(nil), "proto.String")
}

func init() { proto.RegisterFile("pubsubservice.proto", fileDescriptor_9a3c17a182e409fe) }

var fileDescriptor_9a3c17a182e409fe = []byte{
	// 128 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2e, 0x28, 0x4d, 0x2a,
	0x2e, 0x4d, 0x2a, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17,
	0x62, 0x05, 0x53, 0x4a, 0x52, 0x5c, 0x6c, 0xc1, 0x25, 0x45, 0x99, 0x79, 0xe9, 0x42, 0x02, 0x5c,
	0xcc, 0x61, 0x89, 0x45, 0x12, 0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6, 0x51, 0x0a, 0x97,
	0x58, 0x40, 0x69, 0x52, 0x70, 0x69, 0x52, 0x30, 0x44, 0xa7, 0x67, 0x5e, 0x49, 0x6a, 0x51, 0x5a,
	0x62, 0x72, 0xaa, 0x90, 0x32, 0x17, 0x73, 0x40, 0x69, 0x92, 0x10, 0x2f, 0xc4, 0x2c, 0x3d, 0x88,
	0x09, 0x52, 0xa8, 0x5c, 0x21, 0x55, 0x2e, 0xe6, 0x60, 0x42, 0x8a, 0x0c, 0x18, 0x93, 0xd8, 0xc0,
	0x7c, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd1, 0x4e, 0xb9, 0xd2, 0xa6, 0x00, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PubSubServiceInterfaceClient is the client API for PubSubServiceInterface service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PubSubServiceInterfaceClient interface {
	Pub(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error)
	Sub(ctx context.Context, in *String, opts ...grpc.CallOption) (PubSubServiceInterface_SubClient, error)
}

type pubSubServiceInterfaceClient struct {
	cc *grpc.ClientConn
}

func NewPubSubServiceInterfaceClient(cc *grpc.ClientConn) PubSubServiceInterfaceClient {
	return &pubSubServiceInterfaceClient{cc}
}

func (c *pubSubServiceInterfaceClient) Pub(ctx context.Context, in *String, opts ...grpc.CallOption) (*String, error) {
	out := new(String)
	err := c.cc.Invoke(ctx, "/proto.PubSubServiceInterface/Pub", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pubSubServiceInterfaceClient) Sub(ctx context.Context, in *String, opts ...grpc.CallOption) (PubSubServiceInterface_SubClient, error) {
	stream, err := c.cc.NewStream(ctx, &_PubSubServiceInterface_serviceDesc.Streams[0], "/proto.PubSubServiceInterface/Sub", opts...)
	if err != nil {
		return nil, err
	}
	x := &pubSubServiceInterfaceSubClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PubSubServiceInterface_SubClient interface {
	Recv() (*String, error)
	grpc.ClientStream
}

type pubSubServiceInterfaceSubClient struct {
	grpc.ClientStream
}

func (x *pubSubServiceInterfaceSubClient) Recv() (*String, error) {
	m := new(String)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// PubSubServiceInterfaceServer is the server API for PubSubServiceInterface service.
type PubSubServiceInterfaceServer interface {
	Pub(context.Context, *String) (*String, error)
	Sub(*String, PubSubServiceInterface_SubServer) error
}

// UnimplementedPubSubServiceInterfaceServer can be embedded to have forward compatible implementations.
type UnimplementedPubSubServiceInterfaceServer struct {
}

func (*UnimplementedPubSubServiceInterfaceServer) Pub(ctx context.Context, req *String) (*String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pub not implemented")
}
func (*UnimplementedPubSubServiceInterfaceServer) Sub(req *String, srv PubSubServiceInterface_SubServer) error {
	return status.Errorf(codes.Unimplemented, "method Sub not implemented")
}

func RegisterPubSubServiceInterfaceServer(s *grpc.Server, srv PubSubServiceInterfaceServer) {
	s.RegisterService(&_PubSubServiceInterface_serviceDesc, srv)
}

func _PubSubServiceInterface_Pub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(String)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PubSubServiceInterfaceServer).Pub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.PubSubServiceInterface/Pub",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PubSubServiceInterfaceServer).Pub(ctx, req.(*String))
	}
	return interceptor(ctx, in, info, handler)
}

func _PubSubServiceInterface_Sub_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(String)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PubSubServiceInterfaceServer).Sub(m, &pubSubServiceInterfaceSubServer{stream})
}

type PubSubServiceInterface_SubServer interface {
	Send(*String) error
	grpc.ServerStream
}

type pubSubServiceInterfaceSubServer struct {
	grpc.ServerStream
}

func (x *pubSubServiceInterfaceSubServer) Send(m *String) error {
	return x.ServerStream.SendMsg(m)
}

var _PubSubServiceInterface_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.PubSubServiceInterface",
	HandlerType: (*PubSubServiceInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Pub",
			Handler:    _PubSubServiceInterface_Pub_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Sub",
			Handler:       _PubSubServiceInterface_Sub_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pubsubservice.proto",
}
